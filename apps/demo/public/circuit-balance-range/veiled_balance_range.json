{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"11238179556481280099","abi":{"parameters":[{"name":"wallet_secret_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"actual_balance","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"random_secret","type":{"kind":"field"},"visibility":"private"},{"name":"wallet_pubkey_hash","type":{"kind":"field"},"visibility":"public"},{"name":"minimum_balance","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"balance_range_bucket","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"domain_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/8WYS29SQRTHzwVaKPT9ou/eviyUUijuXJE0Jq6MS2NiGmOJYSEqQROXXbrT+AXcu/fxMfwI3XXZhcaVQU47Qy/D/849Q9J0Enp6//ObM48zcOeMR1cloezLZ/VGpWPvqWev84kryyVlaB7QYkCLAy0BtCGgDQMtCbQU0EaAlgZaBmijQBsD2jjQJoA2CbQpoE0DbQZos0CbA9o80LJAWwDaItCWgLYMtBWgrQJtDWjrQPM7n6qhbQFtW2nBsqGsr2ySootmo2AvyEbAsR7WDsd7WSucMFgbPGSyFni4jw2Hk/1sKJwCbBg8gtgQOA1ZDGcwC+HREBbBY2EsgMdD2X54IpztgyctrAlP2VgDnrayvfCMne2BZyPYIDwXxQbg+Uj2Gs5Gs114QcBqeFHCKnhJxF7ByzL2El4RsgyvStkOvCZmKbkeYMsnD5tnh1/yPx7d/3Z6+vhp7u75g/c/X386Ovvz+aJTvyn3O6bPLjFQqTWfRMXzHca4Fe3Xs1X6JGsbnNeusjlN6JceC1XDQ0LWUbdDnwabfAj7UbHeroPfHA22qJ4x16h+gmOKWhfbBjP7jfLlC9h2u/3v6+8VWOfbm8JNk1d2TxN60+Tp+hSvNYaqhte4rPPuIHySb448yYO2R/LFu4WgnX//sADrfHtTGLSCsvua0AEqUH/QGKoaXm8yaAWSB22f5It3C0HLFp5cwDrf3hQGrajsgSZ0gIrUHzSGqobXmwxakeRBOyC3xXMNDn/rC+T+s12S99FTYo79uKxVmeTz7v5xnHOZnM8y8ZJDH4fktq6u66nj7cvceyU1Jtfzm8vbpEJucx5kj1fIPd7bNNgedzvueUcbYpZ+OZzH/+6QfK535H6zm4EHXlPeG/x7yfPmOw2+q9D3gnxnwHcBnONz7s45OefanENzbsw5L+eynKNy7sk5JeeKnAPyO5xzNs7FOMfigxjnRJzr6BxmQ/XJhcfFx2GO246ak1n0HlhS9qTerD1v1d/VjuuNVu1FrXn85u2rVr3WaKUUoW064MG8EbKUmG6fGaz95WqaJR34P2N2qGwCtPNCnmOGtbGmHtRGQZ32Oa1scLx6Hv8B2NsBBf4WAAA=","debug_symbols":"pZXLjoIwFED/pWsWvX1Sf2UyMRWrIWmAVDCZGP99LthWXcCirI5Q70nvg/ZBzu40XY9td+lv5PDzIKfQet9ej75v7Nj2Hb59PCuSHo9jcA5fkY91jBpscN1IDt3kfUXu1k/Ln26D7RaONuAqrYjrzkgUXlrv5l/P6h1N10NrLWOwoXUOl/AVD+vxUFMVBVCD2GtgvMSgDc0GyvYa2GoWG3U0RicBZatbUBtbMAqSwWi62yALkgDKZc5C6xIDKJMMbL0VWwZOWTJwvj6SG91kUoqoYFJDmcLUSaHAFCmUUFmh6qJSyNxQbmiJQZhswKKsprExVQxomgkGAGUKyP3Aqdi9i1IF42+F2b+LUsW7FlzuVoiisZAqn1Y46F+GX3yyTRu+LirCJR5xFeFqPhmQOrKONC8KOn/3SIhkkTxSzKOMlJEqUkfOPkxOmBcljYRIFskj53hsicT45di+29Dak3fxdr1MXfNx2Y5/Q1pJ1/EQ+sadp+DmfJc1rMA/","file_map":{"51":{"source":"// * Balance range proof circuit\n// * Proves that a wallet's SOL balance is within a range and above a minimum,\n// * without revealing the exact balance.\n// *\n// * Public inputs:\n// * - wallet_pubkey_hash: commitment to wallet (same scheme as wallet_ownership circuit)\n// * - minimum_balance: minimum required balance (lamports)\n// * - balance_range_bucket: categorical bucket for range\n// * - domain_hash: domain-scoped identifier\n// * - nullifier: domain-scoped nullifier\n\nfn main(\n    // Private inputs\n    wallet_secret_key: [u8; 32],\n    actual_balance: u64,\n    random_secret: Field,\n\n    // Public inputs\n    wallet_pubkey_hash: pub Field,\n    minimum_balance: pub u64,\n    balance_range_bucket: pub u64,\n    domain_hash: pub Field,\n    nullifier: pub Field,\n) {\n    // STEP 1: Convert secret key bytes to Field (reuse wallet_ownership pattern)\n    let secret_field = bytes_to_field(wallet_secret_key);\n\n    // STEP 2: Compute wallet pubkey hash (commitment)\n    let computed_pubkey_hash = simple_hash(secret_field);\n    assert(computed_pubkey_hash == wallet_pubkey_hash);\n\n    // STEP 3: Ensure balance meets minimum requirement (integer comparison)\n    assert(actual_balance >= minimum_balance);\n\n    // STEP 4: Compute balance range bucket and verify claimed bucket\n    let computed_bucket = compute_range_bucket(actual_balance);\n    assert(computed_bucket == balance_range_bucket);\n\n    // STEP 5: Compute and verify nullifier (domain-scoped)\n    let computed_nullifier =\n        simple_hash_3(computed_pubkey_hash, domain_hash, random_secret);\n    assert(computed_nullifier == nullifier);\n}\n\n// * Helper: Convert bytes to Field (same as wallet_ownership circuit)\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    result\n}\n\n// * Simplified hash (placeholder) - same function as wallet_ownership\nfn simple_hash(input: Field) -> Field {\n    input * 7 + 13\n}\n\n// * Simplified 3-input hash function for nullifier generation\nfn simple_hash_3(a: Field, b: Field, c: Field) -> Field {\n    (a * 11 + b * 13 + c * 17) * 19 + 23\n}\n\n// * Compute which balance range bucket the balance falls into.\n// * Ranges are defined in lamports (1 SOL = 1_000_000_000 lamports):\n// * 0: [0, 10 SOL)\n// * 1: [10, 100 SOL)\n// * 2: [100, 1000 SOL)\n// * 3: [1000 SOL, +inf)\nfn compute_range_bucket(balance: u64) -> u64 {\n    let ten_sol: u64 = 10_000_000_000;\n    let hundred_sol: u64 = 100_000_000_000;\n    let thousand_sol: u64 = 1_000_000_000_000;\n\n    if balance < ten_sol {\n        0\n    } else if balance < hundred_sol {\n        1\n    } else if balance < thousand_sol {\n        2\n    } else {\n        3\n    }\n}\n\n","path":"/home/digitaldrreamer/Documents/Projects/veiled/packages/circuit-balance-range/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}