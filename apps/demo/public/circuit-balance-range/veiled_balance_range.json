{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2950457866655730941,"abi":{"parameters":[{"name":"wallet_secret_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"actual_balance","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"random_secret","type":{"kind":"field"},"visibility":"private"},{"name":"wallet_pubkey_hash","type":{"kind":"field"},"visibility":"public"},{"name":"minimum_balance","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"balance_range_bucket","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"domain_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9WZ93LiMBDGZUwSSkgjvZJyoRPJJbbvr3sVfMD7P8KxQboYeTEu68ygGSLyOfPLsvsJzK7BVstaPn7L58byYcodVk3TDESrIJqJaFVE20O0fUQ7QLQaotURrYFoTUQ7RLQWoh0h2jGinSDaKaKdIVob0c4R7QLRLhHtCtGuEe0G0W4R7Q7R7hHtAdEeEe0J0TrLxx9Ne0W0N6lF17Pclc49XmitsXgxmrHOKkSr6KwCNDPOyk2rYqyctD2clYu2v4mVg3awmZWZVktiZaTVk1mZaI1trAy05nZWatphGlZKWisdKxXtKC0rBe04PWsr7SQLawvtNBsrkXaWlZVAa2dnbaSd52FtoF3kY6G0y7wshHaVnxWjXRdhabSbYqw12m1RVoR2V5z1n3ZPwZK0BxrWF+2RirWkPUVYNv90nLlnzYUtptwKQt/ljht++sIXru/OLN+2577je0EYeDwQjj0XCzewFxL2QhfXrCo5FRZfSiP6X6JDmIPX/HEJXUBeOhk7mteu3HvwI3rT3mPxm/ZqsUBigXVKSn5GFtdYoksYV68kUxhaLYrG2SWsa9IB1uPmxdaah3jGtVit2TRcOOLvzx26vtwHKiHq0PXZdxdHaQMWP4hmseBiwXYY3eHpMzpTDgiLu1umnPuh5wfC/zlTDuU+UglRBhyyuClHbLdMOWR0phwRFne3TCk8K3SnkAck3FJMOZb7RCVEGXDM4qacsN0y5ZjRmXJCXFxq88GnwpDR37Z80MW4ZuoKcZyUteaEdWEl1YQz8u9q9gdhjILYN9R+UeeFqs6QO0FfE9K7PYu4JmW8h1klnJc3Vs57GOnX9WXUz2RxzgRdv2jh/SKsxTtZXMIzIjV4idRFzeRNeR3mZzD3UjN0mA/BXAfmMTBHgfkHzC1g3gBzAujvQ18e+unQB4f+NfSdoV8MfV7oz0JfFfqh0MeE/iP0DaHf12Gr2eteJC5onYAHIY/vLL6U32tyr8u9EblukuWNW4rfLIf/NRfUVyPyvKldU++ZVbY5N/rvFW1P+ltdj2ot5JpituUejVe9jn+eBNw1PCIAAA==","debug_symbols":"tdXLboQgFIDhd2HtgouA+CpNM0HFCQlBg9qkMfPuxckwsdQu5nJ2HuHn22BcUWea5Xyyvh8mVH+syA2tnu3g47Qixq/vplH7bZxmHWZUE8x4gYzvtkcpLwXqrTOoFvTyWSAmDhsiVGoopnkjn2iqJxr1eFPiw4ZhmhrGqn1T/NlMOS9vmymXJAcINEChAQYNlG8AVJUAQVQOcGhAQAMSGqheB0Qp7oCockABAxxDAwQaoNAAgwb++Q44uQMK583x1eZCpiZe3F9NHJpgnbPn0/5/Fl9/6WB148xt7Bff7lbn7zGtpH4MQ2u6JZjtpOtaPP4H","file_map":{"62":{"source":"// * Balance range proof circuit\n// * Proves that a wallet's SOL balance is within a range and above a minimum,\n// * without revealing the exact balance.\n// *\n// * Public inputs:\n// * - wallet_pubkey_hash: commitment to wallet (same scheme as wallet_ownership circuit)\n// * - minimum_balance: minimum required balance (lamports)\n// * - balance_range_bucket: categorical bucket for range\n// * - domain_hash: domain-scoped identifier\n// * - nullifier: domain-scoped nullifier\n\nfn main(\n    // Private inputs\n    wallet_secret_key: [u8; 32],\n    actual_balance: u64,\n    random_secret: Field,\n\n    // Public inputs\n    wallet_pubkey_hash: pub Field,\n    minimum_balance: pub u64,\n    balance_range_bucket: pub u64,\n    domain_hash: pub Field,\n    nullifier: pub Field,\n) {\n    // STEP 1: Convert secret key bytes to Field (reuse wallet_ownership pattern)\n    let secret_field = bytes_to_field(wallet_secret_key);\n\n    // STEP 2: Compute wallet pubkey hash (commitment)\n    let computed_pubkey_hash = simple_hash(secret_field);\n    assert(computed_pubkey_hash == wallet_pubkey_hash);\n\n    // STEP 3: Ensure balance meets minimum requirement (integer comparison)\n    assert(actual_balance >= minimum_balance);\n\n    // STEP 4: Compute balance range bucket and verify claimed bucket\n    let computed_bucket = compute_range_bucket(actual_balance);\n    assert(computed_bucket == balance_range_bucket);\n\n    // STEP 5: Compute and verify nullifier (domain-scoped)\n    let computed_nullifier =\n        simple_hash_3(computed_pubkey_hash, domain_hash, random_secret);\n    assert(computed_nullifier == nullifier);\n}\n\n// * Helper: Convert bytes to Field (same as wallet_ownership circuit)\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    result\n}\n\n// * Simplified hash (placeholder) - same function as wallet_ownership\nfn simple_hash(input: Field) -> Field {\n    input * 7 + 13\n}\n\n// * Simplified 3-input hash function for nullifier generation\nfn simple_hash_3(a: Field, b: Field, c: Field) -> Field {\n    (a * 11 + b * 13 + c * 17) * 19 + 23\n}\n\n// * Compute which balance range bucket the balance falls into.\n// * Ranges are defined in lamports (1 SOL = 1_000_000_000 lamports):\n// * 0: [0, 10 SOL)\n// * 1: [10, 100 SOL)\n// * 2: [100, 1000 SOL)\n// * 3: [1000 SOL, +inf)\nfn compute_range_bucket(balance: u64) -> u64 {\n    let ten_sol: u64 = 10_000_000_000;\n    let hundred_sol: u64 = 100_000_000_000;\n    let thousand_sol: u64 = 1_000_000_000_000;\n\n    if balance < ten_sol {\n        0\n    } else if balance < hundred_sol {\n        1\n    } else if balance < thousand_sol {\n        2\n    } else {\n        3\n    }\n}\n\n","path":"/home/digitaldrreamer/Documents/Projects/veiled/packages/circuit-balance-range/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient"]}