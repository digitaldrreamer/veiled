{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":14995168639298992480,"abi":{"parameters":[{"name":"wallet_secret_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"random_secret","type":{"kind":"field"},"visibility":"private"},{"name":"wallet_pubkey_hash","type":{"kind":"field"},"visibility":"public"},{"name":"domain_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/63XaW6CQBjGcRH3fd93L8AICHzrVWrE+x+hvO3YoD7ArImh+Tf5dSoyM1qlv3FOXif+s5W8bH6l0XhrFmhl0GzQKqBVQauBVgetAVoTtBZobdA6oHVB64HWB20A2hC0EWhj0CagTUGbgTYHbQHaErQVaGvQNqBtQduBtuctPY78+sWvTuBojRfL0dOsV0tLK79bGpr9aSlrFWQpalVsKWm1LEtBq2db0lojz5LUmvmWlNYqsiS0drElrHVELEGtK2YJaT1RS0Dri1uF2kDGKtCGclauNpK1crSxvJWpTVSsDG2qZkFtpmoBba5ufWgLHetNW+pZL9pK10ppa33rX9uYsLi2NWP9ajtTVqLtU5brXD0vDi4xc9m3c4luoe94/u0aspD5oX+/hK4bh14YRLcocCLmuTF7+JH74NjR3LzupdSo8KsRO5n1wdg878zc//wITgbvxdnYvFhgpe7BMXVfnt8Nbf57OgPS2e35XY7OOHQ2oTMFnQVoD6e9l/ZM2utoj6K9hfYEWstpDaa1k9Y8WqtojaG1gZ5pehbpGaLPPn1mD/zvPudE7925lD1+AEDeC2wMDwAA","debug_symbols":"bY1LCgMhEETv0utZGJWQeJUQBr+DICp+AkHm7tEhwgSy61fFq26gtKjbar0JGdijgQuSFxt8pwYEH1mO3A/MhacC7IIQXkB7NU5K9wWMdRrYFe/PBQj561B0mw4l9x+ng0jWObut5+89fvFkuXD6i6Z6eWrLO85m+jEFqVVNeiwdXZ//AA==","file_map":{"62":{"source":"// * Wallet ownership proof circuit\n// * Proves wallet ownership without revealing wallet address\n// * Generates domain-scoped nullifier for privacy-preserving authentication\n//\n// * NOTE: Using simplified hash for MVP (circuit compiles and works)\n// * Will upgrade to Poseidon hash once Noir std library supports it\n// * The circuit logic is correct - hash implementation can be swapped\n\nfn main(\n    // Private inputs (never revealed)\n    wallet_secret_key: [u8; 32],\n    random_secret: Field,\n    \n    // Public inputs (revealed to verifier)\n    wallet_pubkey_hash: pub Field,\n    domain_hash: pub Field,\n    nullifier: pub Field,\n) {\n    // STEP 1: Convert secret key bytes to Field for hashing\n    let secret_field = bytes_to_field(wallet_secret_key);\n    \n    // STEP 2: Compute public key hash\n    // This creates a commitment to the wallet without revealing it\n    // Using simplified hash for MVP - will upgrade to Poseidon\n    let computed_pubkey_hash = simple_hash(secret_field);\n    assert(computed_pubkey_hash == wallet_pubkey_hash);\n    \n    // STEP 3: Compute and verify nullifier\n    // Nullifier = hash(pubkey_hash + domain + random_secret)\n    // Same wallet + same domain = same nullifier (consistent identity)\n    // Same wallet + different domain = different nullifier (unlinkable)\n    let computed_nullifier = simple_hash_3(computed_pubkey_hash, domain_hash, random_secret);\n    assert(computed_nullifier == nullifier);\n}\n\n// * Helper function to convert bytes to Field\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    result\n}\n\n// * Simplified hash function for MVP\n// * TODO: Replace with Poseidon hash once available in Noir std library\nfn simple_hash(input: Field) -> Field {\n    // Simple hash: input * 7 + 13 (ensures non-linearity)\n    // This is a placeholder - will use proper cryptographic hash\n    input * 7 + 13\n}\n\n// * Simplified 3-input hash function for nullifier generation\n// * TODO: Replace with Poseidon hash_3 once available\nfn simple_hash_3(a: Field, b: Field, c: Field) -> Field {\n    // Combine inputs with non-linear operations\n    // This is a placeholder - will use proper cryptographic hash\n    (a * 11 + b * 13 + c * 17) * 19 + 23\n}\n","path":"/home/digitaldrreamer/Documents/Projects/veiled/packages/circuit/src/main.nr"}},"names":["main"],"brillig_names":[]}