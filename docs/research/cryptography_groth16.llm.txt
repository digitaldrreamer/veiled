# Cryptographic Primitives & Groth16 for ZK Systems
## Complete Reference for Privacy Proofs & Verification

**Last Updated:** January 2026
**Papers:** https://eprint.iacr.org
**Academic Resources:** https://zkintro.com
**Implementation:** https://github.com/noir-lang/noir

---

## OVERVIEW

Building Veiled requires understanding:
1. **Hash Functions** - Commitment & nullifier generation
2. **Public Key Cryptography** - Wallet ownership
3. **Groth16 Proof System** - Efficient ZK proofs
4. **Elliptic Curves** - Ed25519 for Solana

All implemented via Noir circuits and verified on-chain.

---

## PART 1: HASH FUNCTIONS

### What is a Hash Function?

A hash function H: M → {0,1}^n takes arbitrary-length input and produces fixed-length output with properties:
- **Deterministic:** Same input = same output
- **Pre-image resistant:** Can't find input from output
- **Collision resistant:** Can't find two different inputs with same output
- **Avalanche effect:** Small input change = completely different output

### Poseidon Hash (Circuit-Optimized)

**Best for:** Inside Noir circuits (designed for constraint efficiency)

```noir
use dep::std::hash::poseidon::bn254::hash_1;

// Single input
let h1 = hash_1([x]);

// Multiple inputs
let h2 = hash_2([x, y]);
let h3 = hash_3([x, y, z]);

// Used for:
// - Nullifier: hash(wallet, domain, secret)
// - Merkle tree leaves
// - Commitments

fn generate_nullifier(
    wallet: Field,
    domain: Field,
    secret: [u8; 32],
) -> pub Field {
    hash_3([
        wallet,
        domain,
        field_from_bytes(secret),
    ])
}
```

**Properties:**
- ~50 constraints per hash
- No lookup tables
- Efficient field arithmetic
- 128-bit security

**Constraint Cost:** ~50 CU in circuit

### SHA-256 (Standard Hash)

**Best for:** Interacting with external systems, blockchain signatures

```noir
use dep::std::hash::sha256;

fn hash_with_sha256(data: [u8; 32]) -> [u8; 32] {
    sha256(data)
}

// Solana uses SHA-256 in some contexts
// Ethereum uses Keccak-256
```

**Properties:**
- 1,600+ constraints per hash
- NIST standard
- Widely compatible
- Industry standard

**Constraint Cost:** ~1,600 CU in circuit

### Keccak-256 (Ethereum-Compatible)

**Best for:** Cross-chain compatibility with Ethereum

```noir
use dep::std::hash::keccak256;

fn hash_with_keccak(data: [u8; 32]) -> [u8; 32] {
    keccak256(data)
}
```

**Comparison Table:**

| Hash | Constraints | Speed | Use Case |
|------|------------|-------|----------|
| Poseidon | ~50 | Fast | Circuit-native |
| SHA-256 | ~1,600 | Medium | Interop |
| Keccak-256 | ~1,700 | Medium | Ethereum |

**For Veiled:** Use Poseidon inside Noir circuits

---

## PART 2: PUBLIC KEY CRYPTOGRAPHY

### Ed25519 (Solana Native)

Solana uses Ed25519 for all wallet signatures. Noir has built-in support.

**Understanding Ed25519:**

```noir
// Ed25519 signature verification

fn verify_ed25519_signature(
    public_key: [u8; 32],        // Wallet pubkey
    message: [u8; 32],           // Message hash
    signature: [u8; 64],         // Signature (r, s)
) -> bool {
    // Verify: signature is valid for (pubkey, message) pair
    // Implementation: Curve25519 math
    true
}
```

**Solana Context:**

```noir
use dep::std::ec::derive_public_key;

fn prove_wallet_ownership(
    secret_key: [u8; 32],        // Private (don't reveal!)
    public_key: pub [u8; 32],    // Public
) {
    // Prove: public_key = derive(secret_key)
    let derived = derive_public_key(secret_key);
    assert(derived == public_key);
}
```

### ECDSA (Bitcoin/Ethereum)

```noir
use dep::std::ec::ecdsa_verify;

fn verify_ecdsa(
    public_key_x: Field,
    public_key_y: Field,
    message_hash: Field,
    r: Field,
    s: Field,
) -> bool {
    ecdsa_verify(public_key_x, public_key_y, message_hash, r, s)
}
```

### Key Derivation

```noir
// Derive public key from secret
fn derive_public(secret: [u8; 32]) -> [u8; 32] {
    let pubkey = derive_public_key(secret);
    pubkey
}

// Use for proving wallet control without revealing secret
fn prove_wallet_for_domain(
    secret: [u8; 32],
    domain: Field,
) -> pub Field {
    let wallet = derive_public_key(secret);
    let nullifier = hash_2([
        field_from_bytes(wallet),
        domain
    ]);
    nullifier
}
```

**Why This Matters for Veiled:**
- Prove wallet ownership without revealing address
- Generate unique nullifier per domain
- Support existing Solana wallets

---

## PART 3: NULLIFIERS (CRITICAL FOR VEILED)

### What is a Nullifier?

A **nullifier** is a hash-based identifier that:
- Uniquely identifies an action (but anonymously)
- Prevents double-spending/replay
- Cannot be reversed to find the secret

**Structure:** `nullifier = hash(secret_key, domain)`

### Nullifier Properties

```
Property                    | Example
============================+=================================
Same secret, same domain   | nullifier₁ = nullifier₂
Same secret, diff domain   | nullifier₁ ≠ nullifier₂  
                          | (different applications)
                          
Cannot reverse            | Can't find secret from nullifier
Cannot predict           | Don't know nullifier before hash
```

### Nullifier Implementation in Noir

```noir
use dep::std::hash::poseidon::bn254::hash_3;

fn generate_nullifier(
    secret: [u8; 32],
    domain: Field,
    salt: [u8; 32],
) -> pub Field {
    hash_3([
        field_from_bytes(secret),
        domain,
        field_from_bytes(salt),
    ])
}

fn prove_nullifier(
    secret: [u8; 32],
    domain: pub Field,
    salt: [u8; 32],
    claimed_nullifier: pub Field,
) {
    let computed = generate_nullifier(secret, domain, salt);
    assert(computed == claimed_nullifier);
    
    // Proves:
    // 1. Know secret, domain, salt
    // 2. Commitment is correct
    // Without revealing any of them!
}
```

### On-Chain Nullifier Storage (Anchor)

```rust
// Store nullifiers as PDAs to prevent reuse

#[account]
pub struct NullifierAccount {
    pub nullifier_hash: [u8; 32],
    pub used: bool,
    pub timestamp: i64,
}

#[derive(Accounts)]
pub struct RecordNullifier<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + 32 + 1 + 8,
        seeds = [b"nullifier", nullifier_hash.as_ref()],
        bump
    )]
    pub nullifier: Account<'info, NullifierAccount>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

pub fn mark_nullifier_used(
    ctx: Context<RecordNullifier>,
) -> Result<()> {
    let nullifier = &mut ctx.accounts.nullifier;
    require!(!nullifier.used, ErrorCode::AlreadyUsed);
    
    nullifier.used = true;
    nullifier.timestamp = Clock::get()?.unix_timestamp;
    
    emit!(NullifierMarked {
        hash: nullifier.nullifier_hash,
    });
    
    Ok(())
}
```

---

## PART 4: GROTH16 PROOF SYSTEM

### What is Groth16?

Groth16 is a zero-knowledge SNARK (Succinct Non-Interactive Argument of Knowledge) with:
- **Succinctness:** Proof size ~256 bytes (constant)
- **Non-interactive:** No back-and-forth communication
- **Arguments:** Computationally sound (not perfect)
- **Knowledge:** Prover demonstrates knowledge

**Key Properties:**
```
Input Size    | Proof Size    | Verification Time
==============|===============|==================
Small         | ~256 bytes    | <5ms
Large         | ~256 bytes    | <5ms
Huge          | ~256 bytes    | <5ms

↳ Proof size is INDEPENDENT of circuit complexity!
```

### How Groth16 Works

1. **Setup Phase** (once per circuit):
   - Generate proving key (PK)
   - Generate verification key (VK)
   - Publish VK (can be stored on-chain)

2. **Proving Phase** (per proof):
   - Take private inputs and circuit
   - Use PK to generate proof (π)
   - Proof is ~256 bytes

3. **Verification Phase** (on-chain):
   - Check proof π against VK
   - Takes <200,000 compute units on Solana
   - Deterministic: always same result

### Groth16 Proof Structure

```
Proof = (A, B, C)

Where:
A ∈ G₁  (32 bytes)
B ∈ G₂  (64 bytes)
C ∈ G₁  (32 bytes)
────────────────
Total: 128 bytes (or 256 with extra encoding)

On Solana: Serialized as u8 arrays in big-endian
```

### Noir → Groth16 Compilation

```bash
# Step 1: Write circuit in Noir
nargo new my_circuit
# ... write src/main.nr ...

# Step 2: Compile to Groth16
nargo compile --include-keys

# Step 3: Outputs generated
# target/my_circuit.acir         # Circuit IR
# target/verification_key.json   # For on-chain verification
# target/my_circuit.wasm         # For browser proof generation

# Step 4: Extract verification key for Solana
cat target/verification_key.json | jq .
```

### On-Chain Groth16 Verification (Solana)

```rust
use groth16_solana::Groth16Verifier;

#[derive(Accounts)]
pub struct VerifyProof<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
}

pub fn verify_groth16(
    ctx: Context<VerifyProof>,
    proof: Vec<u8>,
    public_inputs: Vec<[u8; 32]>,
) -> Result<()> {
    // Parse proof (must be big-endian)
    require!(proof.len() == 256, ErrorCode::InvalidProofSize);
    
    let proof_a = (&proof[0..64]).try_into()?;
    let proof_b = (&proof[64..192]).try_into()?;
    let proof_c = (&proof[192..256]).try_into()?;
    
    // Load verification key
    const VERIFYING_KEY: &[u8] = include_bytes!("../vk.bin");
    
    // Create verifier
    let mut verifier = Groth16Verifier::new(
        &proof_a,
        &proof_b,
        &proof_c,
        public_inputs.as_slice(),
        VERIFYING_KEY,
    )?;
    
    // Verify
    verifier.verify()?;
    
    msg!("Proof verified!");
    Ok(())
}
```

### Compute Unit Analysis

```
Operation              | Compute Units | Time (Solana)
======================|===============|==============
Proof deserialization | ~1,000        | ~1ms
VK loading            | ~5,000        | ~5ms
Pairing check        | ~100,000      | ~50ms
Final verification   | ~200,000      | ~100ms
────────────────────────────────────────────────
**Total: <200,000 CU  | ~100ms total**
```

---

## PART 5: CIRCUIT DESIGN FOR PRIVACY

### Pattern 1: Private Authentication

```noir
// Prove: I know the correct secret
// Without revealing the secret

fn authenticate(
    secret: [u8; 32],              // Private
    expected_hash: pub [u8; 32],   // Public (stored on-chain)
) {
    let computed_hash = sha256(secret);
    assert(computed_hash == expected_hash);
    
    // Proves: know secret such that hash matches
    // No information about secret is revealed!
}
```

### Pattern 2: Nullifier-Based Authentication

```noir
use dep::std::hash::poseidon::bn254::hash_3;

fn authenticate_with_nullifier(
    secret: [u8; 32],
    domain: Field,
    salt: [u8; 32],
) -> pub Field {
    let nullifier = hash_3([
        field_from_bytes(secret),
        domain,
        field_from_bytes(salt),
    ]);
    
    nullifier
    
    // On-chain:
    // 1. Check nullifier not used before
    // 2. Mark as used (prevents replay)
}
```

### Pattern 3: Selective Disclosure

```noir
// Prove: have NFT from collection X
// Without revealing which NFT

fn prove_nft_collection(
    nft_address: [u8; 32],
    collection_id: [u8; 32],
    merkle_path: [[u8; 32]; 5],  // Merkle proof
    merkle_root: pub [u8; 32],   // Public root
    collection: pub [u8; 32],    // Public collection
) {
    // Verify NFT in merkle tree
    let mut leaf = nft_address;
    for i in 0..5 {
        leaf = sha256([leaf, merkle_path[i]]);
    }
    assert(leaf == merkle_root);
    
    // Verify collection match
    assert(collection == collection_id);
    
    // Proves: have valid NFT from collection
    // But not which NFT!
}
```

### Pattern 4: Range Proofs

```noir
// Prove: balance >= minimum
// Without revealing actual balance

fn prove_min_balance(
    balance: Field,
    min_balance: Field,
) {
    // Constraint: balance >= min_balance
    assert(balance >= min_balance);
    
    // Public output: only proves minimum met
    // Actual balance remains private
}
```

---

## PART 6: SECURITY CONSIDERATIONS

### What Groth16 Guarantees

✅ **Soundness:** Cannot forge proof for false statement
✅ **Completeness:** Valid proof always verifies
✅ **Zero-Knowledge:** Verifier learns nothing but the statement

### What Groth16 Does NOT Guarantee

❌ Side-channel resistance (physical attacks)
❌ Protection against weak randomness
❌ Undiscovered cryptographic breaks (pre-image attacks)

### Best Practices

**1. Use Audited Circuits**
```noir
// ✅ GOOD: Well-tested, audited circuit
fn verify_signature(pubkey: [u8; 32], sig: [u8; 64], msg: [u8; 32]) {
    // Standard Ed25519 verification
}

// ❌ BAD: Custom crypto without review
fn my_custom_verification(...) {
    // Don't do this!
}
```

**2. Randomness Quality**
```typescript
// ✅ GOOD: Use cryptographic RNG
const random = crypto.getRandomValues(new Uint8Array(32));

// ❌ BAD: Predictable randomness
const random = Math.random() * 255;
```

**3. Private Input Handling**
```noir
// ✅ GOOD: Keep private inputs truly private
fn handle_secret(secret: [u8; 32], public: pub Field) {
    // Secret is only used inside circuit
    // Never logged, never exposed
}

// ❌ BAD: Exposing private data
let leaked = secret;  // No! This is public!
```

**4. Nullifier Uniqueness**
```noir
// ✅ GOOD: Ensure nullifier depends on multiple inputs
let nullifier = hash_3([wallet, domain, secret]);

// ❌ BAD: Predictable nullifier
let nullifier = hash_1([wallet]);  // Can predict!
```

---

## PART 7: PERFORMANCE BENCHMARKS

### Proof Generation Time

| Circuit Size | Generation Time | Backend |
|------------|-----------------|---------|
| <1,000 constraints | <1 second | Barretenberg |
| 10,000 constraints | 2-5 seconds | Barretenberg |
| 100,000 constraints | 10-30 seconds | Barretenberg |
| 1M constraints | 2-5 minutes | Barretenberg |

**For Veiled (typical):**
- Circuit: ~3,000 constraints
- Generation: ~2 seconds (browser)
- Proof size: 256 bytes
- Verification: <100ms (Solana)

### Compute Unit Breakdown

```
Noir Circuit: prove_authentication()
├── Hash(wallet, domain, secret)        ~50 CU
├── Ed25519 signature verify            ~25,000 CU
├── Nullifier generation                ~50 CU
└── Output commitment                   ~50 CU
────────────────────────────────────────
Total circuit: ~25,150 CU
Plus Groth16 verification: ~200,000 CU
────────────────────────────────────
Total on-chain: <225,000 CU ✓
```

---

## PART 8: COMMON CRYPTOGRAPHIC PATTERNS

### Merkle Tree Verification

```noir
use dep::std::hash::sha256;

fn verify_merkle_proof(
    leaf: Field,
    index: Field,
    path: [Field; 10],
    root: pub Field,
) {
    let mut current = leaf;
    
    for i in 0..10 {
        if (index >> i) & 1 == 1 {
            current = sha256([path[i], current]);
        } else {
            current = sha256([current, path[i]]);
        }
    }
    
    assert(current == root);
}
```

### Commitment Scheme

```noir
fn verify_commitment(
    secret: [u8; 32],
    blinding_factor: [u8; 32],
) -> pub [u8; 32] {
    // Commitment = hash(secret || blinding_factor)
    let commitment = sha256([
        secret.concat(blinding_factor)
    ]);
    
    commitment
}
```

### Signature Aggregation

```noir
fn verify_multiple_signatures(
    public_keys: [[u8; 32]; 3],
    messages: [[u8; 32]; 3],
    signatures: [[u8; 64]; 3],
) -> bool {
    let mut all_valid = true;
    
    for i in 0..3 {
        let valid = verify_ed25519(
            public_keys[i],
            messages[i],
            signatures[i],
        );
        all_valid = all_valid & valid;
    }
    
    all_valid
}
```

---

## REFERENCE MATERIALS

### Papers (Academic)
- **Groth16:** https://eprint.iacr.org/2016/260.pdf
- **zk-SNARKs Overview:** https://eprint.iacr.org/2014/355.pdf
- **Poseidon Hash:** https://eprint.iacr.org/2019/458.pdf

### Implementations
- **Noir stdlib:** https://noir-lang.org/docs/standard_library/
- **Barretenberg:** https://github.com/AztecProtocol/barretenberg
- **groth16-solana:** https://docs.rs/groth16-solana/latest/groth16_solana/

### Educational
- **ZK Whiteboard Sessions:** https://www.youtube.com/playlist?list=PLcPzhzreTe2i9Y1FhLfKWc4RvTv6iMhJx
- **zkIntro:** https://zkintro.com
- **Privacy Pioneer Program:** https://aztec.network/privacy-pioneer

---

**Version:** 1.0  
**Last Updated:** January 2026  
**Authors:** Aztec Labs, Noir Contributors  
**License:** Open Source