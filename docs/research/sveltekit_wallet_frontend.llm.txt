# Frontend Integration: SvelteKit, Solana Wallet Adapter & UI
## Complete Guide for Building Privacy-First Web3 Applications

**Last Updated:** January 2026
**SvelteKit Docs:** https://kit.svelte.dev
**Wallet Adapter Docs:** https://github.com/solana-labs/wallet-adapter
**Solana Docs:** https://docs.solana.com

---

## OVERVIEW

Building the Veiled frontend requires:
1. **SvelteKit:** Full-stack framework (frontend + backend)
2. **Solana Wallet Adapter:** Connect to user wallets
3. **Noir/NoirJS:** Generate ZK proofs in browser
4. **Helius SDK:** Fetch NFT data and send transactions

**Why SvelteKit for Veiled:**
- Compiler-first = smaller bundles (critical for proof generation WASM)
- Built-in SSR for SEO
- Native TypeScript support
- Unified full-stack (no separate backend)
- Excellent for progressive enhancement

---

## SVELTEKIT SETUP

### Create SvelteKit Project

```bash
npm create svelte@latest my_veiled_app
cd my_veiled_app

# Choose options:
# - Skeleton project ✓
# - TypeScript ✓
# - ESLint ✓
# - Prettier ✓
# - Playwright ✓
# - Vitest ✓

npm install
npm run dev
```

### Project Structure

```
my_veiled_app/
├── src/
│   ├── lib/
│   │   ├── components/          # Reusable Svelte components
│   │   │   ├── WalletButton.svelte
│   │   │   ├── ProofGenerator.svelte
│   │   │   └── NFTProof.svelte
│   │   ├── stores/              # Reactive stores
│   │   │   ├── wallet.ts        # Wallet connection state
│   │   │   └── proof.ts         # Proof generation state
│   │   └── utils/               # Utility functions
│   │       ├── noir.ts          # Noir proof generation
│   │       └── helius.ts        # RPC interactions
│   ├── routes/
│   │   ├── +page.svelte         # Home page
│   │   ├── +layout.svelte       # Root layout
│   │   ├── api/
│   │   │   └── verify/
│   │   │       └── +server.ts   # Backend proof verification
│   │   └── auth/
│   │       ├── +page.svelte     # Auth page
│   │       └── +server.ts       # Auth backend
│   └── app.html                 # HTML template
├── static/                      # Static assets
├── svelte.config.js            # SvelteKit config
├── vite.config.ts              # Vite config
└── package.json
```

---

## SOLANA WALLET ADAPTER SETUP

### Installation

```bash
npm install @solana/wallet-adapter-base \
  @solana/wallet-adapter-react \
  @solana/wallet-adapter-react-ui \
  @solana/wallet-adapter-wallets \
  @solana/web3.js
```

### Setup Provider (Root Layout)

```svelte
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { WalletProvider, WalletMultiButton } from '@solana/wallet-adapter-svelte';
  import { PhantomWalletAdapter, BackpackWalletAdapter } from '@solana/wallet-adapter-wallets';
  import { clusterApiUrl } from '@solana/web3.js';
  import '@solana/wallet-adapter-react-ui/styles.css';
  
  let wallets = [];
  
  onMount(() => {
    wallets = [
      new PhantomWalletAdapter(),
      new BackpackWalletAdapter(),
      // Add more wallet adapters
    ];
  });
  
  const network = clusterApiUrl('devnet');
</script>

<WalletProvider {wallets} {network}>
  <div class="app">
    <header>
      <h1>Veiled: Privacy Authentication</h1>
      <WalletMultiButton />
    </header>
    
    <main>
      <slot />
    </main>
  </div>
</WalletProvider>

<style>
  .app {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background: #1a1a1a;
    color: #fff;
  }
  
  main {
    flex: 1;
    padding: 2rem;
  }
</style>
```

### Access Wallet in Components

```svelte
<!-- src/lib/components/WalletBalance.svelte -->
<script lang="ts">
  import { useConnection, useWallet } from '@solana/wallet-adapter-svelte';
  import { onMount } from 'svelte';
  
  let balance = 0;
  let connected = false;
  
  const { connection } = useConnection();
  const { publicKey } = useWallet();
  
  onMount(async () => {
    if ($publicKey) {
      connected = true;
      const balanceLamports = await connection.getBalance($publicKey);
      balance = balanceLamports / 1e9;
    }
  });
</script>

{#if connected}
  <div>Balance: {balance} SOL</div>
{:else}
  <div>Connect wallet to see balance</div>
{/if}
```

---

## WALLET STORE MANAGEMENT

### Create Reactive Wallet Store

```typescript
// src/lib/stores/wallet.ts
import { writable } from 'svelte/store';
import type { PublicKey } from '@solana/web3.js';

export interface WalletStore {
  connected: boolean;
  publicKey: PublicKey | null;
  balance: number;
  nfts: any[];
  loading: boolean;
}

function createWalletStore() {
  const { subscribe, set, update } = writable<WalletStore>({
    connected: false,
    publicKey: null,
    balance: 0,
    nfts: [],
    loading: false,
  });
  
  return {
    subscribe,
    connect: (pubkey: PublicKey) => {
      update((state) => ({
        ...state,
        connected: true,
        publicKey: pubkey,
      }));
    },
    disconnect: () => {
      set({
        connected: false,
        publicKey: null,
        balance: 0,
        nfts: [],
        loading: false,
      });
    },
    setBalance: (balance: number) => {
      update((state) => ({ ...state, balance }));
    },
    setNFTs: (nfts: any[]) => {
      update((state) => ({ ...state, nfts }));
    },
    setLoading: (loading: boolean) => {
      update((state) => ({ ...state, loading }));
    },
  };
}

export const walletStore = createWalletStore();
```

---

## NOIR PROOF GENERATION IN BROWSER

### Setup NoirJS

```bash
npm install @noir-lang/noir_js \
  @noir-lang/backend_barretenberg \
  @noir-lang/noir_wasm
```

### Create Proof Generation Utility

```typescript
// src/lib/utils/noir.ts
import { Noir } from '@noir-lang/noir_js';
import { BarretenbergBackend } from '@noir-lang/backend_barretenberg';
import circuitArtifact from '$lib/circuits/auth';

let noir: Noir;
let backend: BarretenbergBackend;
let initialized = false;

export async function initializeNoir() {
  if (initialized) return;
  
  backend = new BarretenbergBackend();
  noir = new Noir(circuitArtifact);
  initialized = true;
}

export async function generateProof(inputs: Record<string, any>) {
  if (!initialized) {
    await initializeNoir();
  }
  
  try {
    // Generate witness from inputs
    const witness = await noir.generateWitness(inputs);
    
    // Generate proof
    const { proof, publicInputs } = await noir.generateProof(witness);
    
    return {
      success: true,
      proof: Array.from(new Uint8Array(proof)),
      publicInputs,
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
}

export async function verifyProof(
  proof: ArrayBuffer,
  publicInputs: any
) {
  if (!initialized) {
    await initializeNoir();
  }
  
  try {
    const isValid = await noir.verifyProof({ proof, publicInputs });
    return isValid;
  } catch (error) {
    console.error('Verification failed:', error);
    return false;
  }
}
```

### Use in Component with Web Worker (Non-blocking)

```svelte
<!-- src/lib/components/ProofGenerator.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  
  let isProving = false;
  let proofResult = null;
  let error = null;
  let worker: Worker;
  
  onMount(() => {
    // Create web worker to prevent UI blocking
    worker = new Worker(new URL('../../workers/proofWorker.ts', import.meta.url), {
      type: 'module',
    });
    
    worker.onmessage = (event) => {
      const { success, proof, publicInputs, error: workerError } = event.data;
      
      isProving = false;
      
      if (success) {
        proofResult = { proof, publicInputs };
      } else {
        error = workerError;
      }
    };
  });
  
  async function handleProveClick() {
    isProving = true;
    error = null;
    
    // Example inputs (from Noir circuit)
    const inputs = {
      wallet: '12345',
      domain: '1',
      secret: '0x0000000000000000000000000000000000000000000000000000000000000000',
    };
    
    // Send to worker
    worker.postMessage({ inputs });
  }
  
  async function submitProof() {
    if (!proofResult) return;
    
    const response = await fetch('/api/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        proof: proofResult.proof,
        publicInputs: proofResult.publicInputs,
      }),
    });
    
    const result = await response.json();
    
    if (result.success) {
      alert('Authentication successful!');
    } else {
      error = result.error;
    }
  }
</script>

<div class="proof-generator">
  <h2>Generate ZK Proof</h2>
  
  {#if isProving}
    <p>Generating proof... (this may take a few seconds)</p>
  {:else if error}
    <p class="error">{error}</p>
  {:else if proofResult}
    <p class="success">✓ Proof generated successfully!</p>
    <button on:click={submitProof}>Submit Authentication</button>
  {:else}
    <button on:click={handleProveClick}>Generate Proof</button>
  {/if}
</div>

<style>
  .proof-generator {
    padding: 1rem;
    border: 1px solid #ccc;
    border-radius: 8px;
  }
  
  .error {
    color: #ff4444;
  }
  
  .success {
    color: #44ff44;
  }
</style>
```

### Web Worker for Proof Generation

```typescript
// src/workers/proofWorker.ts
import { generateProof } from '$lib/utils/noir';

self.onmessage = async (event) => {
  const { inputs } = event.data;
  
  try {
    const result = await generateProof(inputs);
    self.postMessage(result);
  } catch (error) {
    self.postMessage({
      success: false,
      error: error.message,
    });
  }
};
```

---

## HELIUS INTEGRATION FOR NFT VERIFICATION

```typescript
// src/lib/utils/helius.ts
import { Helius } from '@helius-labs/sdk';

const helius = new Helius(import.meta.env.VITE_HELIUS_API_KEY);

export async function getNFTsByOwner(walletAddress: string) {
  try {
    const assets = await helius.rpc.getAssetsByOwner({
      ownerAddress: walletAddress,
      limit: 1000,
      page: 1,
    });
    
    return assets.items.map((item) => ({
      id: item.id,
      name: item.content?.metadata?.name,
      collection: item.grouping?.[0]?.group_value,
      image: item.content?.links?.image,
    }));
  } catch (error) {
    console.error('Failed to fetch NFTs:', error);
    return [];
  }
}

export async function verifyNFTOwnership(
  wallet: string,
  nftId: string
) {
  const nfts = await getNFTsByOwner(wallet);
  return nfts.some((nft) => nft.id === nftId);
}
```

---

## BACKEND PROOF VERIFICATION

### Create Backend Verification Endpoint

```typescript
// src/routes/api/verify/+server.ts
import type { RequestHandler } from '@sveltejs/kit';

// Import Groth16 verifier (in actual implementation)
// Use groth16-solana crate compiled to WASM or call Solana program

export const POST: RequestHandler = async ({ request }) => {
  const { proof, publicInputs } = await request.json();
  
  try {
    // Verify proof (implementation depends on your setup)
    // Option 1: Call Solana program (on-chain verification)
    // Option 2: Use verification library
    
    const isValid = true; // Placeholder
    
    if (isValid) {
      return new Response(
        JSON.stringify({ success: true, message: 'Authentication verified' }),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      );
    } else {
      return new Response(
        JSON.stringify({ success: false, error: 'Invalid proof' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};
```

---

## ENVIRONMENT VARIABLES

### .env.local

```bash
# Helius
VITE_HELIUS_API_KEY=your_helius_api_key

# Quicknode (optional fallback)
VITE_QUICKNODE_RPC=https://xxx.solana-mainnet.quiknode.pro/xxx/

# Solana Program ID
VITE_PROGRAM_ID=your_solana_program_id

# Network
VITE_NETWORK=devnet
```

### .env.production

```bash
# Same as above, but for mainnet
VITE_HELIUS_API_KEY=your_helius_api_key
VITE_NETWORK=mainnet-beta
VITE_PROGRAM_ID=your_mainnet_program_id
```

---

## UI COMPONENTS (SKELETON)

### Complete Auth Flow Component

```svelte
<!-- src/lib/components/AuthFlow.svelte -->
<script lang="ts">
  import { useConnection, useWallet } from '@solana/wallet-adapter-svelte';
  import { walletStore } from '$lib/stores/wallet';
  import ProofGenerator from './ProofGenerator.svelte';
  import NFTVerifier from './NFTVerifier.svelte';
  
  let step: 'wallet' | 'nft' | 'proof' | 'success' = 'wallet';
  
  const { publicKey, connected } = useWallet();
  
  $: if (connected && $publicKey) {
    walletStore.connect($publicKey);
    step = 'nft';
  }
</script>

<div class="auth-flow">
  <h1>Veiled Authentication</h1>
  
  {#if step === 'wallet'}
    <div class="step">
      <h2>Step 1: Connect Wallet</h2>
      <p>Click the button in the top right to connect your wallet</p>
    </div>
  {/if}
  
  {#if step === 'nft' && connected}
    <div class="step">
      <h2>Step 2: Verify NFT Ownership</h2>
      <NFTVerifier on:verified={() => (step = 'proof')} />
    </div>
  {/if}
  
  {#if step === 'proof'}
    <div class="step">
      <h2>Step 3: Generate ZK Proof</h2>
      <ProofGenerator on:verified={() => (step = 'success')} />
    </div>
  {/if}
  
  {#if step === 'success'}
    <div class="step success">
      <h2>✓ Authentication Successful!</h2>
      <p>You are now authenticated with privacy preserved.</p>
    </div>
  {/if}
</div>

<style>
  .auth-flow {
    max-width: 600px;
    margin: 2rem auto;
  }
  
  .step {
    padding: 2rem;
    border: 1px solid #ddd;
    border-radius: 8px;
    margin: 1rem 0;
  }
  
  .success {
    background: #d4edda;
    border-color: #28a745;
  }
</style>
```

---

## DEPLOYMENT

### Build for Production

```bash
npm run build

# Output in build/
```

### Deploy to Vercel

```bash
npm install -g vercel
vercel
```

### Deploy to Netlify

```bash
npm run build
# Drag/drop build folder to Netlify
```

---

## PERFORMANCE OPTIMIZATION

### Lazy Load Proof Generation

```svelte
<script>
  import { lazy } from 'svelte';
  
  // Only load proof generator when needed
  const ProofGenerator = lazy(() => 
    import('./ProofGenerator.svelte')
  );
</script>

<Suspense>
  <ProofGenerator />
</Suspense>
```

### Cache Circuit WASM

```typescript
// src/lib/utils/noir.ts
const wasmCache = new Map();

export async function initializeNoir() {
  if (wasmCache.has('noir')) {
    return wasmCache.get('noir');
  }
  
  const noir = new Noir(circuitArtifact);
  wasmCache.set('noir', noir);
  return noir;
}
```

---

## TESTING

### Unit Tests (Vitest)

```typescript
// src/lib/utils/noir.test.ts
import { describe, it, expect } from 'vitest';
import { generateProof } from './noir';

describe('Noir Proof Generation', () => {
  it('generates valid proof', async () => {
    const inputs = {
      wallet: '12345',
      domain: '1',
      secret: new Array(32).fill(0),
    };
    
    const result = await generateProof(inputs);
    expect(result.success).toBe(true);
    expect(result.proof).toBeDefined();
  });
});
```

### Integration Tests (Playwright)

```typescript
// tests/auth.spec.ts
import { test, expect } from '@playwright/test';

test('complete auth flow', async ({ page }) => {
  await page.goto('http://localhost:5173');
  
  // Step 1: Connect wallet
  const connectButton = page.getByRole('button', { name: /connect/i });
  await connectButton.click();
  
  // Step 2: Verify NFT
  const verifyButton = page.getByRole('button', { name: /verify/i });
  await verifyButton.click();
  
  // Step 3: Generate proof
  const proveButton = page.getByRole('button', { name: /prove/i });
  await proveButton.click();
  
  // Check success
  await expect(page.getByText(/success/i)).toBeVisible();
});
```

---

## RESOURCES

### Official Docs
- **SvelteKit:** https://kit.svelte.dev/docs
- **Svelte:** https://svelte.dev/docs
- **Wallet Adapter:** https://github.com/solana-labs/wallet-adapter
- **NoirJS:** https://noir-lang.org/docs/tutorials/noirjs_app

### UI Frameworks
- **shadcn-svelte:** https://www.shadcn-svelte.com/
- **SvelteUI:** https://svelteui.org/
- **Tailwind:** https://tailwindcss.com/

### Community
- **Svelte Discord:** https://discord.gg/svelte
- **Solana Discord:** https://discord.gg/solana
- **GitHub Discussions:** https://github.com/solana-labs/wallet-adapter/discussions

---

**Version:** 1.0  
**Last Updated:** January 2026  
**Maintained By:** Svelte Team / Solana  
**License:** Open Source