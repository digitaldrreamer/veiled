# Anchor Framework & Solana Program Development
## Complete Guide for Building ZK-Enabled Smart Contracts

**Last Updated:** January 2026
**Official Website:** https://www.anchor-lang.com
**GitHub:** https://github.com/coral-xyz/anchor
**Documentation:** https://book.anchor-lang.com

---

## OVERVIEW

Anchor is a framework for building secure Solana programs (smart contracts) in Rust. It provides:
- Account validation and safety checks
- IDL (Interface Definition Language) generation
- Transaction instruction serialization
- Cross-program invocations (CPI)
- Program-derived addresses (PDAs)
- Comprehensive error handling
- Built-in security best practices

**Why Anchor for Veiled:**
- Reduces boilerplate by 80%
- Built-in account safety (prevents critical bugs)
- Automatic IDL for JavaScript clients
- Best-in-class error handling
- Production-ready framework

---

## INSTALLATION

### Install Anchor CLI

```bash
# Install Rust first (if needed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Anchor
cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked

# Verify installation
anchor --version

# Install Solana CLI (if needed)
sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
solana --version

# Configure local network
solana config set --url http://127.0.0.1:8899
```

---

## PROJECT STRUCTURE

### Create New Anchor Project

```bash
anchor init my_veiled_program
cd my_veiled_program

# Generated structure:
# my_veiled_program/
# ├── programs/
# │   └── my_veiled_program/
# │       ├── src/
# │       │   └── lib.rs              # Main program code
# │       └── Cargo.toml
# ├── tests/
# │   └── my_veiled_program.ts        # Integration tests
# ├── app/                             # Frontend (optional)
# ├── Anchor.toml                      # Workspace config
# ├── Cargo.toml                       # Workspace Cargo
# └── package.json                     # JavaScript dependencies
```

### Cargo.toml Dependencies (Anchor Program)

```toml
[dependencies]
anchor-lang = "0.30"
anchor-spl = "0.30"
solana-program = "1.18"

# For ZK verification
groth16-solana = "0.0.1"

# For cryptography
solana-sdk = "1.18"
```

---

## CORE CONCEPTS

### 1. ACCOUNTS & ACCOUNT VALIDATION

**In Solana, ALL state is stored in accounts.** An account has:
- `pubkey`: The account's public key (address)
- `owner`: The program that owns this account
- `data`: The account's data (state)
- `lamports`: SOL balance (for rent exemption)

**Example Account Structure:**

```rust
// Define the data stored in an account
#[account]
pub struct NullifierState {
    pub nullifier_hash: [u8; 32],      // The nullifier
    pub used: bool,                     // Has this been used?
    pub timestamp: i64,                 // When was it created?
}

// Anchor will automatically:
// - Handle serialization/deserialization
// - Calculate account size
// - Set correct discriminator
```

### 2. PROGRAM DERIVED ADDRESSES (PDAs)

PDAs are deterministic addresses derived from a program ID and seeds. They have NO associated keypair.

**Key Properties:**
- Idempotent: Same seeds = same address (every time)
- Deterministic: Can be derived without private key
- Program-owned: Only the program can modify accounts at this address
- Authority: Program proves it owns the PDA via the bump seed

**Example - Storing Nullifiers:**

```rust
// PDA = hash(program_id, b"nullifier", nullifier_hash, bump)
#[derive(Accounts)]
pub struct CreateNullifier<'info> {
    #[account(
        init,                          // Create new account
        payer = user,                  // Who pays for rent?
        space = 8 + 32 + 1 + 8,       // Discriminator + data size
        seeds = [b"nullifier", nullifier_hash.as_ref()],
        bump                           // Canonical bump for PDA
    )]
    pub nullifier_account: Account<'info, NullifierState>,
    
    #[account(mut)]
    pub user: Signer<'info>,           // Must sign transaction
    pub system_program: Program<'info, System>,
}

pub fn create_nullifier(
    ctx: Context<CreateNullifier>,
    nullifier_hash: [u8; 32],
) -> Result<()> {
    let nullifier = &mut ctx.accounts.nullifier_account;
    nullifier.nullifier_hash = nullifier_hash;
    nullifier.used = false;
    nullifier.timestamp = Clock::get()?.unix_timestamp;
    Ok(())
}
```

**Why This Matters for Veiled:**
- Each nullifier gets a unique PDA
- Prevents double-spending/double-voting
- Deterministic so client can verify address

### 3. INSTRUCTION ACCOUNTS

The `#[derive(Accounts)]` macro validates all accounts before instruction execution.

```rust
#[derive(Accounts)]
pub struct VerifyAuth<'info> {
    // Signer: Account must sign the transaction
    #[account(mut)]
    pub payer: Signer<'info>,
    
    // Account: Owned by program, deserialized to type
    #[account(
        mut,
        owner = *program_id,
        seeds = [b"nullifier", nullifier.as_ref()],
        bump = nullifier_bump
    )]
    pub nullifier: Account<'info, NullifierState>,
    
    // System Program: Always required for account creation
    pub system_program: Program<'info, System>,
    
    // Unsecure Account: For data you don't control
    pub unchecked: AccountInfo<'info>,
    
    // With constraints
    #[account(constraint = authority.key() == ADMIN)]
    pub authority: Signer<'info>,
}

pub fn verify_auth(
    ctx: Context<VerifyAuth>,
    proof: Vec<u8>,
) -> Result<()> {
    // All accounts are validated before this runs
    // ...
}
```

### 4. CONSTRAINTS

Constraints are checked by Anchor before instruction execution. Failure reverts the transaction.

```rust
#[derive(Accounts)]
pub struct TransferNullifier<'info> {
    // Constraint: value must match
    #[account(
        constraint = source.key() != destination.key(),
        constraint = source.owner == *program_id,
    )]
    pub source: Account<'info, NullifierState>,
    
    pub destination: Account<'info, NullifierState>,
    
    // Constraint: must be owner
    #[account(
        constraint = owner.key() == source.owner @ ErrorCode::Unauthorized
    )]
    pub owner: Signer<'info>,
}
```

**Common Constraints:**
```rust
// Signer requirements
#[account(signer)]

// Mutable accounts
#[account(mut)]

// Value constraints
#[account(constraint = account.value == expected)]

// PDA validation
#[account(seeds = [b"seed"], bump)]

// Owner validation
#[account(owner = *program_id)]

// Init with rent exemption
#[account(init, payer = payer, space = 8 + 100)]

// Init if not exists
#[account(init_if_needed, payer = payer, space = 8 + 100)]

// Close account, return lamports to receiver
#[account(close = receiver)]
```

---

## WRITING PROGRAMS

### Basic Program Structure

```rust
use anchor_lang::prelude::*;

declare_id!("YOUR_PROGRAM_ID_HERE");

#[program]
pub mod veiled {
    use super::*;
    
    // Handler: Main instruction function
    pub fn create_nullifier(
        ctx: Context<CreateNullifier>,
        nullifier: [u8; 32],
    ) -> Result<()> {
        // Validation (Anchor handles account checks)
        
        // Business logic
        let state = &mut ctx.accounts.nullifier_state;
        state.nullifier = nullifier;
        state.used = false;
        
        // Emit events
        emit!(NullifierCreated { nullifier });
        
        Ok(())
    }
    
    pub fn mark_used(ctx: Context<MarkUsed>) -> Result<()> {
        let state = &mut ctx.accounts.nullifier_state;
        
        // Prevent double-use
        require!(!state.used, ErrorCode::AlreadyUsed);
        
        state.used = true;
        emit!(NullifierUsed {
            nullifier: state.nullifier,
        });
        
        Ok(())
    }
}

// Account struct
#[account]
pub struct NullifierState {
    pub nullifier: [u8; 32],
    pub used: bool,
    pub creator: Pubkey,
    pub created_at: i64,
}

// Events
#[event]
pub struct NullifierCreated {
    pub nullifier: [u8; 32],
}

#[event]
pub struct NullifierUsed {
    pub nullifier: [u8; 32],
}

// Error codes
#[error_code]
pub enum ErrorCode {
    #[msg("Nullifier already used")]
    AlreadyUsed,
    
    #[msg("Unauthorized")]
    Unauthorized,
    
    #[msg("Invalid proof")]
    InvalidProof,
}
```

### Account Contexts

```rust
// Context 1: Initialize nullifier
#[derive(Accounts)]
#[instruction(nullifier: [u8; 32])]  // Instruction args available
pub struct CreateNullifier<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + 32 + 1 + 32 + 8,  // Discriminator + struct size
        seeds = [b"nullifier", nullifier.as_ref()],
        bump
    )]
    pub nullifier_state: Account<'info, NullifierState>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

// Context 2: Mark as used
#[derive(Accounts)]
pub struct MarkUsed<'info> {
    #[account(
        mut,
        seeds = [b"nullifier", nullifier_state.nullifier.as_ref()],
        bump,
    )]
    pub nullifier_state: Account<'info, NullifierState>,
    
    pub user: Signer<'info>,
}
```

---

## GROTH16 PROOF VERIFICATION

### Using groth16-solana Crate

```rust
use groth16_solana::Groth16Verifier;

#[derive(Accounts)]
pub struct VerifyProof<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

pub fn verify_auth_proof(
    ctx: Context<VerifyProof>,
    proof: Vec<u8>,
    public_inputs: Vec<[u8; 32]>,
) -> Result<()> {
    // Parse proof (must be big-endian u8 arrays)
    let proof_a = (&proof[0..64]).try_into()
        .map_err(|_| error!(ErrorCode::InvalidProof))?;
    let proof_b = (&proof[64..192]).try_into()
        .map_err(|_| error!(ErrorCode::InvalidProof))?;
    let proof_c = (&proof[192..256]).try_into()
        .map_err(|_| error!(ErrorCode::InvalidProof))?;
    
    // Verification key (from Noir circuit)
    const VERIFYING_KEY: &[u8] = include_bytes!("../vk.bin");
    
    // Verify proof
    let mut verifier = Groth16Verifier::new(
        &proof_a,
        &proof_b,
        &proof_c,
        public_inputs.as_slice(),
        VERIFYING_KEY,
    )
    .map_err(|_| error!(ErrorCode::InvalidProof))?;
    
    verifier.verify()
        .map_err(|_| error!(ErrorCode::InvalidProof))?;
    
    Ok(())
}
```

**Proof Size:** ~256 bytes (Groth16)
**Verification Cost:** <200,000 compute units

---

## TESTING PROGRAMS

### Unit Testing (Anchor)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use anchor_lang::AnchorSerialize;
    
    #[test]
    fn test_create_nullifier() {
        // Setup
        let program_id = Pubkey::new_unique();
        let nullifier = [0u8; 32];
        
        // Test
        // (Note: Full testing requires running against local validator)
    }
}
```

### Integration Testing (TypeScript)

```typescript
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";

describe("Veiled", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);
    const program = anchor.workspace.Veiled as Program<Veiled>;
    
    it("creates a nullifier", async () => {
        const nullifier = new Uint8Array(32);
        crypto.getRandomValues(nullifier);
        
        const [nullifierPda] = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("nullifier"), Buffer.from(nullifier)],
            program.programId,
        );
        
        const tx = await program.methods
            .createNullifier(Array.from(nullifier))
            .accounts({
                nullifierState: nullifierPda,
                payer: provider.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            })
            .rpc();
        
        console.log("Transaction:", tx);
    });
    
    it("verifies proof", async () => {
        const proof = [/* ... */];
        const publicInputs = [/* ... */];
        
        const tx = await program.methods
            .verifyAuthProof(proof, publicInputs)
            .accounts({
                payer: provider.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            })
            .rpc();
        
        console.log("Verified:", tx);
    });
});
```

### Running Tests

```bash
# Build program
anchor build

# Start local validator
solana-test-validator

# Run tests (in another terminal)
anchor test

# Or test against devnet
anchor test --skip-deploy --skip-local-validator \
  --provider.cluster devnet
```

---

## CROSS-PROGRAM INVOCATIONS (CPI)

### Calling Another Program from Your Program

```rust
use anchor_lang::system_program;

#[derive(Accounts)]
pub struct InvokeOtherProgram<'info> {
    #[account(mut)]
    pub account: Account<'info, SomeAccount>,
    pub other_program: Program<'info, OtherProgram>,
    pub system_program: Program<'info, System>,
}

pub fn invoke_other(ctx: Context<InvokeOtherProgram>) -> Result<()> {
    let cpi_program = ctx.accounts.other_program.to_account_info();
    let cpi_accounts = OtherAccountsContext {
        account: ctx.accounts.account.to_account_info(),
        // ...
    };
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    
    other_program::cpi::some_instruction(cpi_ctx)?;
    
    Ok(())
}
```

**Example: Storing Verification Key on-chain via CPI**

```rust
pub fn store_verification_key_via_cpi(
    ctx: Context<StoreVK>,
    vk_data: Vec<u8>,
) -> Result<()> {
    // Call token program to mint verification key account
    // (or any other program interaction)
    
    Ok(())
}
```

---

## COMPUTE UNIT OPTIMIZATION

### Check Compute Units Used

```bash
# Enable logging
solana logs

# Run program and watch compute unit usage
anchor test
```

### Optimization Strategies

```rust
// ❌ BAD: Inefficient
pub fn inefficient(ctx: Context<MyContext>) -> Result<()> {
    for i in 0..100 {
        ctx.accounts.account.value += i;  // 100 writes
    }
    Ok(())
}

// ✅ GOOD: Efficient
pub fn efficient(ctx: Context<MyContext>) -> Result<()> {
    let sum: u64 = (0..100).sum();
    ctx.accounts.account.value += sum;    // 1 write
    Ok(())
}
```

### Proof Verification Costs

```
Constraint Type          | CU Cost
========================+==========
Poseidon Hash           | ~2,000
SHA-256                 | ~15,000
Groth16 Verification    | <200,000
Merkle Proof (4 levels) | ~8,000
Ed25519 Verify          | ~25,000
```

---

## RENT EXEMPTION

Accounts must be rent-exempt to stay on-chain permanently.

### Calculate Required Lamports

```rust
fn calculate_rent(space: usize) -> Result<u64> {
    let rent = Rent::get()?;
    Ok(rent.minimum_balance(space))
}

// Example: NullifierState
// space = 8 (discriminator) + 32 (nullifier) + 1 (bool) + 32 (creator) + 8 (timestamp)
// = 81 bytes
// Required: ~738,000 lamports (~0.00738 SOL)
```

### In Anchor:

```rust
#[derive(Accounts)]
pub struct CreateNullifier<'info> {
    #[account(
        init,
        payer = payer,                    // Payer covers rent
        space = 8 + 32 + 1 + 32 + 8,
        seeds = [b"nullifier", nullifier.as_ref()],
        bump
    )]
    pub nullifier_state: Account<'info, NullifierState>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}
```

---

## ERROR HANDLING

### Custom Error Codes

```rust
#[error_code]
pub enum ErrorCode {
    #[msg("Proof verification failed")]
    ProofVerificationFailed,
    
    #[msg("Nullifier already used")]
    NullifierAlreadyUsed,
    
    #[msg("Invalid signer")]
    InvalidSigner,
}

// Usage
pub fn verify_auth(ctx: Context<VerifyAuth>) -> Result<()> {
    require!(proof_is_valid, ErrorCode::ProofVerificationFailed);
    Ok(())
}
```

### Using require! and require_gte!

```rust
// Boolean check
require!(condition, ErrorCode::MyError);

// Comparison checks
require_gt!(a, b, ErrorCode::MustBeGreater);
require_gte!(a, b, ErrorCode::MustBeGreaterOrEqual);
require_lt!(a, b, ErrorCode::MustBeLess);
require_lte!(a, b, ErrorCode::MustBeLessOrEqual);
require_neq!(a, b, ErrorCode::MustNotEqual);
require_eq!(a, b, ErrorCode::MustEqual);

// Key checks
require_keys_eq!(key1, key2, ErrorCode::KeysMustMatch);
require_keys_neq!(key1, key2, ErrorCode::KeysMustNotMatch);
```

---

## EVENTS

### Emitting Events

```rust
#[event]
pub struct AuthProofVerified {
    pub nullifier: [u8; 32],
    pub timestamp: i64,
    pub user: Pubkey,
}

pub fn verify_auth(ctx: Context<VerifyAuth>, proof: Vec<u8>) -> Result<()> {
    // ... verification ...
    
    emit!(AuthProofVerified {
        nullifier: nullifier_hash,
        timestamp: Clock::get()?.unix_timestamp,
        user: ctx.accounts.payer.key(),
    });
    
    Ok(())
}
```

### Listening to Events (Client-side)

```typescript
const listener = program.addEventListener("AuthProofVerified", (event) => {
    console.log("Verified:", event);
});

// Later
program.removeEventListener(listener);
```

---

## SECURITY BEST PRACTICES

### 1. Account Validation
```rust
// Always validate account ownership
#[account(owner = *program_id)]
pub account: Account<'info, MyAccount>,
```

### 2. Signer Checks
```rust
// Always check who's signing
#[account(signer)]
pub user: Signer<'info>,

require_keys_eq!(user.key(), expected_user, ErrorCode::Unauthorized);
```

### 3. PDA Verification
```rust
// Use seeds and bump for deterministic PDAs
#[account(
    seeds = [b"nullifier", nullifier.as_ref()],
    bump = pda_bump,
)]
pub pda: Account<'info, MyAccount>,
```

### 4. Integer Overflow
```rust
// Rust's checked_add prevents overflow panics
let result = a.checked_add(b)
    .ok_or(error!(ErrorCode::Overflow))?;
```

### 5. Rent Exemption
```rust
// Always ensure accounts are rent-exempt
#[account(init, payer = payer, space = 8 + 100)]
pub account: Account<'info, MyAccount>,
```

### 6. Instruction Ordering
```rust
// Anchor validates accounts BEFORE execution
// No need to manually check in handler
pub fn handler(ctx: Context<MyContext>) -> Result<()> {
    // All constraints already satisfied
    Ok(())
}
```

---

## DEPLOYMENT

### Build Program

```bash
# Development build
anchor build

# Output:
# target/deploy/veiled-keypair.json    # Program keypair
# target/deploy/veiled.so              # Compiled program
# target/idl/veiled.json               # Interface definition

# Optimized build (larger programs)
anchor build --release
```

### Deploy to Devnet

```bash
# Get devnet SOL
solana airdrop 2 --url devnet

# Set cluster
solana config set --url devnet

# Deploy
anchor deploy --provider.cluster devnet

# Output: Program deployed to [PROGRAM_ID]
```

### Deploy to Mainnet-beta

```bash
# ⚠️ Costs real SOL!
solana config set --url mainnet-beta

# Check program size and cost
solana program show target/deploy/veiled.so

# Deploy
anchor deploy --provider.cluster mainnet-beta
```

### Upgrade Program

```bash
# Programs are upgradeable (if you hold the upgrade authority)
anchor deploy --provider.cluster devnet --program-name veiled
```

---

## COMMON PATTERNS FOR VEILED

### Pattern 1: Nullifier Storage

```rust
#[account]
pub struct Nullifier {
    pub hash: [u8; 32],
    pub domain: u64,
    pub created_at: i64,
    pub used: bool,
}

#[derive(Accounts)]
pub struct RecordNullifier<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + 32 + 8 + 8 + 1,
        seeds = [b"nullifier", nullifier.as_ref()],
        bump
    )]
    pub nullifier: Account<'info, Nullifier>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

### Pattern 2: Proof Verification with Nullifiers

```rust
pub fn prove_authentication(
    ctx: Context<ProveAuth>,
    proof: Vec<u8>,
    public_inputs: Vec<[u8; 32]>,
) -> Result<()> {
    // Verify proof
    let nullifier = public_inputs[0];
    verify_groth16_proof(&proof, &public_inputs)?;
    
    // Check nullifier not already used
    require!(!ctx.accounts.nullifier.used, ErrorCode::AlreadyUsed);
    
    // Mark nullifier as used
    ctx.accounts.nullifier.used = true;
    ctx.accounts.nullifier.created_at = Clock::get()?.unix_timestamp;
    
    emit!(ProofVerified { nullifier });
    Ok(())
}
```

### Pattern 3: Selective Domain-Based Verification

```rust
pub fn authenticate_for_domain(
    ctx: Context<AuthDomain>,
    proof: Vec<u8>,
    domain: u64,
) -> Result<()> {
    // Proof encodes domain inside
    // Verify and check against the provided domain
    
    let nullifier = derive_nullifier_for_domain(&proof, domain)?;
    
    require!(!ctx.accounts.nullifier.used, ErrorCode::AlreadyUsed);
    
    Ok(())
}
```

---

## RESOURCES & DOCUMENTATION

### Official Docs
- **Getting Started:** https://book.anchor-lang.com
- **API Reference:** https://docs.rs/anchor-lang
- **Examples:** https://github.com/coral-xyz/anchor/tree/master/examples

### Solana Docs
- **Solana Cookbook:** https://solanacookbook.com
- **Program Examples:** https://github.com/solana-developers/program-examples
- **Official Docs:** https://docs.solana.com

### Community
- **Anchor Discord:** https://discord.gg/anchorlang
- **Solana Discord:** https://discord.gg/solana
- **Stack Exchange:** https://solana.stackexchange.com

---

## PERFORMANCE BENCHMARKS (2025)

| Operation | Compute Units | Time |
|-----------|---------------|------|
| Account creation (init) | ~3,000 | 5-10ms |
| Proof verification (Groth16) | <200,000 | 50-100ms |
| PDA derivation | ~100 | <1ms |
| Account modification | ~100-500 | 1-5ms |
| CPI invocation | ~100 | 1-2ms |

---

**Version:** 1.0  
**Last Updated:** January 2026  
**Maintainer:** Coral XYZ / Anchor Contributors  
**License:** Open Source (Apache 2.0 / MIT)