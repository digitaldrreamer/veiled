# Solana RPC Integration: Helius & Quicknode
## Complete Guide for High-Performance Blockchain Infrastructure

**Last Updated:** January 2026
**Helius Docs:** https://docs.helius.dev
**Quicknode Docs:** https://www.quicknode.com/docs/solana
**Official Solana Docs:** https://docs.solana.com

---

## OVERVIEW

RPC (Remote Procedure Call) providers give you access to Solana network data and transaction submission. Two premium providers:

**Helius:**
- Enhanced APIs for Solana-specific data
- NFT/Asset APIs (critical for Veiled)
- WebSocket support for real-time events
- Free tier: 100k credits/month
- Enterprise-grade reliability

**Quicknode:**
- Standard Solana RPC with add-ons
- Multi-chain support (if you expand)
- 100% uptime SLA
- Free tier: 100k requests/day
- Easy provider switching

---

## HELIUS RPC INTEGRATION

### Installation

```bash
npm install @helius-labs/sdk axios
```

### API Key Setup

```bash
# Get free API key
# 1. Visit https://dashboard.helius.dev
# 2. Create account
# 3. Copy API key
# 4. Add to .env

HELIUS_API_KEY=your_api_key_here
```

### Basic RPC Methods

```typescript
import { Helius } from "@helius-labs/sdk";
import { PublicKey, Connection } from "@solana/web3.js";

const helius = new Helius(process.env.HELIUS_API_KEY);

// Standard RPC: Get balance
async function getBalance(wallet: string) {
    const pubkey = new PublicKey(wallet);
    const balance = await helius.connection.getBalance(pubkey);
    return balance / 1e9;  // Convert to SOL
}

// Standard RPC: Get account info
async function getAccountInfo(account: string) {
    const info = await helius.connection.getAccountInfo(
        new PublicKey(account)
    );
    return info;
}

// Standard RPC: Send transaction
async function sendTransaction(
    signedTx: string
) {
    const signature = await helius.connection.sendRawTransaction(
        Buffer.from(signedTx, "base64")
    );
    return signature;
}

// Standard RPC: Simulate transaction
async function simulateTransaction(signedTx: string) {
    const result = await helius.connection.simulateTransaction(
        Buffer.from(signedTx, "base64")
    );
    return result;
}
```

### Enhanced APIs: Asset & NFT Data

**Critical for Veiled:**

```typescript
import { DAS } from "@helius-labs/sdk";

// Get all NFTs owned by wallet
async function getNFTsByOwner(walletAddress: string) {
    const assets = await helius.rpc.getAssetsByOwner({
        ownerAddress: walletAddress,
        page: 1,
        limit: 1000,
    });
    
    return assets.items.map((item) => ({
        id: item.id,
        name: item.content?.metadata?.name,
        collection: item.grouping?.[0]?.group_value,
        owner: walletAddress,
    }));
}

// Get NFT details
async function getNFTDetails(assetId: string) {
    const asset = await helius.rpc.getAsset({
        id: assetId,
    });
    
    return {
        name: asset.content?.metadata?.name,
        symbol: asset.content?.metadata?.symbol,
        image: asset.content?.links?.image,
        collection: asset.grouping,
        royalties: asset.royalty,
    };
}

// Get NFTs in collection
async function getNFTsByCollection(collectionAddress: string) {
    const assets = await helius.rpc.getAssetsByGroup({
        groupKey: "collection",
        groupValue: collectionAddress,
        page: 1,
    });
    
    return assets.items;
}

// Get ownership proof
async function getOwnershipProof(
    walletAddress: string,
    nftAddress: string
) {
    const assets = await helius.rpc.getAssetsByOwner({
        ownerAddress: walletAddress,
    });
    
    const owns = assets.items.some((item) => item.id === nftAddress);
    return owns;
}
```

### WebSocket Subscriptions (Real-time)

```typescript
// Subscribe to account changes
helius.connection.onAccountChange(
    new PublicKey("PROGRAM_ID"),
    (accountInfo) => {
        console.log("Account updated:", accountInfo);
    }
);

// Subscribe to slot updates
helius.connection.onSlotChange((slotInfo) => {
    console.log("Current slot:", slotInfo.slot);
});

// Subscribe to signature confirmations
helius.connection.onSignature(
    "SIGNATURE_HERE",
    (sigInfo) => {
        console.log("Status:", sigInfo);
    }
);
```

### Smart Transaction (Optimized Fees)

```typescript
import { TransactionInstruction, PublicKey } from "@solana/web3.js";

async function sendSmartTransaction(
    instructions: TransactionInstruction[],
    signers: any[]
) {
    try {
        // Helius automatically optimizes:
        // - Priority fee calculation
        // - Compute unit estimation
        // - Bundling strategy (if applicable)
        
        const signature = await helius.sendSmartTransaction(
            instructions,
            signers,
            [],  // lookup tables
            {
                priorityFeeCap: 1_000_000,  // Max fee in microlamports
            }
        );
        
        console.log("Transaction confirmed:", signature);
        return signature;
    } catch (error) {
        console.error("Transaction failed:", error);
    }
}
```

### Priority Fee Estimation

```typescript
async function estimatePriorityFee(
    instructions: TransactionInstruction[]
) {
    // Get recommended priority fee
    const estimate = await helius.rpc.getPriorityFeeEstimate({
        accountKeys: [/* affected accounts */],
        options: {
            percentile: 0.75,  // 75th percentile (median-high)
        },
    });
    
    return estimate.priorityFeeEstimate;
}
```

### Polling Transactions

```typescript
async function waitForConfirmation(
    signature: string,
    maxAttempts = 120,
    intervalMs = 1000
) {
    for (let i = 0; i < maxAttempts; i++) {
        const status = await helius.connection.getSignatureStatus(
            signature,
            {
                searchTransactionHistory: true,
            }
        );
        
        if (status.value?.confirmationStatus === "finalized") {
            return true;
        }
        
        await new Promise((resolve) => setTimeout(resolve, intervalMs));
    }
    
    throw new Error("Transaction not confirmed");
}
```

---

## QUICKNODE RPC INTEGRATION

### Installation

```bash
npm install @solana/web3.js axios
```

### Setup Connection

```typescript
import { Connection, PublicKey } from "@solana/web3.js";

const QUICKNODE_RPC = process.env.QUICKNODE_RPC_URL;
// Example: https://xxx.solana-mainnet.quiknode.pro/xxxx/

const connection = new Connection(QUICKNODE_RPC, "confirmed");

// Standard RPC methods work the same
async function getBalance(wallet: string) {
    const balance = await connection.getBalance(new PublicKey(wallet));
    return balance / 1e9;
}
```

### Standard Solana RPC Methods

```typescript
// Get account balance
const balance = await connection.getBalance(walletPubkey);

// Get parsed token accounts
const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
    walletPubkey,
    { programId: TOKEN_PROGRAM_ID }
);

// Get program accounts
const accounts = await connection.getProgramAccounts(programId);

// Get account info
const accountInfo = await connection.getAccountInfo(accountPubkey);

// Get latest blockhash
const { blockhash, lastValidBlockHeight } = 
    await connection.getLatestBlockhash("confirmed");

// Send transaction
const signature = await connection.sendRawTransaction(
    signedTx.serialize()
);

// Simulate transaction
const simulation = await connection.simulateTransaction(tx);

// Get transaction
const tx = await connection.getTransaction(signature);

// Get block info
const block = await connection.getBlock(slot);

// Get token supply
const supply = await connection.getTokenSupply(mint);
```

---

## CHOOSING BETWEEN HELIUS & QUICKNODE

### Use Helius When:
✅ Need NFT/Asset data (best APIs)
✅ Need selective disclosure (Range integration)
✅ Want smart transaction optimization
✅ Building privacy-focused app
✅ Need WebSocket real-time updates

### Use Quicknode When:
✅ Standard RPC only
✅ Cost optimization (straightforward billing)
✅ Multi-chain in future
✅ Simple integration
✅ No special Solana features needed

### For Veiled (Recommended):
**Helius Primary + Quicknode Fallback**

```typescript
import { Helius } from "@helius-labs/sdk";
import { Connection } from "@solana/web3.js";

const helius = new Helius(process.env.HELIUS_API_KEY);
const quicknodeConnection = new Connection(
    process.env.QUICKNODE_RPC_URL
);

async function getBalanceWithFallback(wallet: string) {
    try {
        // Try Helius first
        return await helius.connection.getBalance(new PublicKey(wallet));
    } catch (error) {
        console.warn("Helius failed, using Quicknode");
        return await quicknodeConnection.getBalance(new PublicKey(wallet));
    }
}

async function checkNFTOwnership(
    wallet: string,
    nftAddress: string
) {
    try {
        // Helius has better NFT APIs
        const assets = await helius.rpc.getAssetsByOwner({
            ownerAddress: wallet,
            limit: 1000,
        });
        
        return assets.items.some((item) => item.id === nftAddress);
    } catch (error) {
        // Fallback to manual check
        const accounts = await quicknodeConnection.getProgramAccounts(
            TOKEN_METADATA_PROGRAM_ID
        );
        // Manual verification logic
    }
}
```

---

## RATE LIMITS & COST OPTIMIZATION

### Helius Rate Limits (Free Tier)

| Plan | Credits/Month | Max RPS | Price |
|------|---------------|---------|-------|
| Free | 100,000 | 10 | $0 |
| Growth | 1,000,000 | 25 | $29/mo |
| Pro | 5,000,000 | 50 | $99/mo |

**Credits per request:**
- Standard RPC: 10 credits
- Enhanced APIs: 50-500 credits
- Asset lookups: 100 credits
- WebSocket: 1 credit/second

### Quicknode Rate Limits (Free Tier)

| Plan | Requests/Day | Max RPS | Price |
|------|-------------|---------|-------|
| Free | 100,000 | 5 | $0 |
| Starter | 1,000,000 | 50 | $25/mo |
| Pro | 10,000,000 | 100 | $99/mo |

### Cost Optimization

```typescript
// ❌ BAD: Makes 1000 separate requests
for (const wallet of wallets) {
    const balance = await helius.connection.getBalance(wallet);
}

// ✅ GOOD: Batch requests
const balances = await helius.connection.getMultipleAccountsInfo(
    wallets.map((w) => new PublicKey(w))
);

// ✅ GOOD: Cache results
const cache = new Map();

async function getBalanceCached(wallet: string) {
    if (cache.has(wallet)) {
        return cache.get(wallet);
    }
    
    const balance = await helius.connection.getBalance(
        new PublicKey(wallet)
    );
    cache.set(wallet, balance);
    
    // Refresh every 10 seconds
    setTimeout(() => cache.delete(wallet), 10000);
    return balance;
}
```

---

## HELIUS API REFERENCE

### getAssetsByOwner (Critical for Veiled)

```typescript
interface GetAssetsByOwnerOptions {
    ownerAddress: string;          // Wallet address
    page?: number;                 // Page number (default: 1)
    limit?: number;                // Items per page (default: 1000)
    before?: string;               // Cursor for pagination
    after?: string;                // Cursor for pagination
    sortBy?: "recent_action" | "recently_received" | "name";
    sort_direction?: "asc" | "desc";
}

// Returns
interface GetAssetsByOwnerResult {
    total: number;
    limit: number;
    page: number;
    items: Asset[];
}

interface Asset {
    id: string;                    // Token address
    interface: string;             // "FungibleToken" | "NonFungible" | etc
    content?: {
        $schema?: string;
        $metadata?: {
            name?: string;
            symbol?: string;
        };
        files?: Array<{
            uri?: string;
            mime?: string;
        }>;
        links?: {
            image?: string;
            external_url?: string;
        };
    };
    grouping?: Array<{
        group_key: string;         // "collection"
        group_value: string;       // Collection address
    }>;
}
```

### getAssetsByGroup

```typescript
interface GetAssetsByGroupOptions {
    groupKey: string;              // "collection"
    groupValue: string;            // Collection address
    page?: number;
    limit?: number;
}

// Returns: GetAssetsByOwnerResult
```

### searchAssets

```typescript
interface SearchAssetsOptions {
    nft_owner?: string;            // Filter by owner
    creator?: string;              // Filter by creator
    authoritiy?: string;           // Filter by authority
    compressed?: boolean;          // Filter compressed
    ownable?: boolean;             // Filter ownable
    grouping?: string;             // Filter by collection
    burnt?: boolean;               // Filter burnt
    json_uri?: string;             // Filter by metadata URI
    page?: number;
    limit?: number;
}

// Returns: GetAssetsByOwnerResult
```

---

## EXAMPLE: PROVING NFT OWNERSHIP FOR VEILED

```typescript
import { Helius } from "@helius-labs/sdk";
import { PublicKey } from "@solana/web3.js";

async function proofOfNFTOwnership(
    walletAddress: string,
    nftCollection: string
) {
    const helius = new Helius(process.env.HELIUS_API_KEY);
    
    // Step 1: Get all NFTs owned by wallet
    const assets = await helius.rpc.getAssetsByOwner({
        ownerAddress: walletAddress,
        limit: 1000,
    });
    
    // Step 2: Filter for collection
    const ownsInCollection = assets.items.filter(
        (item) => item.grouping?.[0]?.group_value === nftCollection
    );
    
    if (ownsInCollection.length === 0) {
        return {
            proven: false,
            reason: "No NFTs in collection",
        };
    }
    
    // Step 3: Generate proof
    return {
        proven: true,
        nfts: ownsInCollection.map((item) => ({
            id: item.id,
            name: item.content?.metadata?.name,
            image: item.content?.links?.image,
        })),
        count: ownsInCollection.length,
    };
}

// Usage
const proof = await proofOfNFTOwnership(
    "wallet_address",
    "collection_address"
);
```

---

## MONITORING & LOGGING

### Transaction Monitoring

```typescript
async function monitorTransaction(
    signature: string,
    onConfirmed?: (tx: any) => void,
    onFailed?: (error: any) => void
) {
    const helius = new Helius(process.env.HELIUS_API_KEY);
    
    try {
        await helius.pollTransactionConfirmation(
            signature,
            {
                interrupt: false,
                maxRetries: 30,
            }
        );
        
        const tx = await helius.connection.getTransaction(signature);
        onConfirmed?.(tx);
    } catch (error) {
        onFailed?.(error);
    }
}
```

### Error Handling

```typescript
async function sendWithErrorHandling(
    instructions: TransactionInstruction[],
    signers: any[]
) {
    try {
        const signature = await helius.sendSmartTransaction(
            instructions,
            signers
        );
        console.log("Success:", signature);
    } catch (error: any) {
        if (error.code === "BLOCKHASH_NOT_FOUND") {
            console.error("Blockhash expired");
        } else if (error.code === "INSUFFICIENT_FUNDS") {
            console.error("Not enough SOL");
        } else if (error.logs) {
            console.error("Program error:", error.logs);
        } else {
            console.error("Unknown error:", error);
        }
    }
}
```

---

## BOUNTY REQUIREMENTS

### Helius Integration Checklist
- ✅ Use Helius RPC endpoint
- ✅ Use enhanced APIs (getAssetsByOwner, searchAssets)
- ✅ Handle rate limits gracefully
- ✅ Document Helius integration
- ✅ Show in demo video
- ✅ Easy switching between providers

### Quicknode Integration Checklist
- ✅ Support Quicknode RPC
- ✅ Fallback mechanism
- ✅ Open source (MIT)
- ✅ Document how to switch
- ✅ Easy configuration (.env)

---

## RESOURCES

### Official Docs
- **Helius:** https://docs.helius.dev
- **Quicknode:** https://www.quicknode.com/docs/solana
- **Solana RPC API:** https://docs.solana.com/api/http

### Support
- **Helius Discord:** https://discord.gg/helius
- **Quicknode Support:** support@quicknode.com
- **Solana Discord:** https://discord.gg/solana

---

**Version:** 1.0  
**Last Updated:** January 2026  
**Maintained By:** Helius Labs / Quicknode  
**License:** Open Source